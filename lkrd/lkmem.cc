#ifndef _MSC_VER
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/sysinfo.h>
#include <fcntl.h>
#include <unistd.h>
#include <errno.h>
#include <net/if.h>
#endif

#include <iostream>
#include <elfio/elfio_dump.hpp>
#include "ksyms.h"
#include "getopt.h"
#include "x64_disasm.h"
#include "arm64_disasm.h"
#include "arm64relocs.h"
#ifndef _MSC_VER
#include "../shared.h"
#include "kmods.h"
#include "lk.h"
#include "minfo.h"
#endif

int g_opt_v = 0;

using namespace ELFIO;

struct x64_thunk
{
  const char *name;
  ud_type reg;
};

void usage(const char *prog)
{
  printf("%s usage: [options] image [symbols]\n", prog);
  printf("Options:\n");
  printf("-b - check .bss section\n");
  printf("-c - check memory. Achtung - you must first load lkcd driver\n");
  printf("-d - use disasm\n");
  printf("-F - dump super-blocks\n");
  printf("-f - dump ftraces\n");  
  printf("-k - dump kprobes\n");
  printf("-n - dump nets\n");
  printf("-r - check .rodata section\n");
  printf("-S - check security_hooks\n");
  printf("-s - check fs_ops for sysfs files\n");
  printf("-u - dump usb_monitor\n");
  printf("-v - verbose mode\n");
  exit(6);
}

static a64 s_security_hook_heads = 0;

// autogenerated from include/linux/lsm_hook_defs.h
std::vector<lsm_hook> s_hooks = {
 { "binder_set_context_mgr" },
 { "binder_transaction" },
 { "binder_transfer_binder" },
 { "binder_transfer_file" },
 { "ptrace_access_check" },
 { "ptrace_traceme" },
 { "capget" },
 { "capset" },
 { "capable" },
 { "quotactl" },
 { "quota_on" },
 { "syslog" },
 { "settime" },
 { "vm_enough_memory" },
 { "bprm_creds_for_exec" },
 { "bprm_creds_from_file" },
 { "bprm_check_security" },
 { "bprm_committing_creds" },
 { "bprm_committed_creds" },
 { "fs_context_dup" },
 { "fs_context_parse_param" },
 { "sb_alloc_security" },
 { "sb_free_security" },
 { "sb_free_mnt_opts" },
 { "sb_eat_lsm_opts" },
 { "sb_remount" },
 { "sb_kern_mount" },
 { "sb_show_options" },
 { "sb_statfs" },
 { "sb_mount" },
 { "sb_umount" },
 { "sb_pivotroot" },
 { "sb_set_mnt_opts" },
 { "sb_clone_mnt_opts" },
 { "sb_add_mnt_opt" },
 { "move_mount" },
 { "dentry_init_security" },
 { "dentry_create_files_as" },
 { "path_unlink" },
 { "path_mkdir" },
 { "path_rmdir" },
 { "path_mknod" },
 { "path_truncate" },
 { "path_symlink" },
 { "path_link" },
 { "path_rename" },
 { "path_chmod" },
 { "path_chown" },
 { "path_chroot" },
 { "path_notify" },
 { "inode_alloc_security" },
 { "inode_free_security" },
 { "inode_init_security" },
 { "inode_create" },
 { "inode_link" },
 { "inode_unlink" },
 { "inode_symlink" },
 { "inode_mkdir" },
 { "inode_rmdir" },
 { "inode_mknod" },
 { "inode_rename" },
 { "inode_readlink" },
 { "inode_follow_link" },
 { "inode_permission" },
 { "inode_setattr" },
 { "inode_getattr" },
 { "inode_setxattr" },
 { "inode_post_setxattr" },
 { "inode_getxattr" },
 { "inode_listxattr" },
 { "inode_removexattr" },
 { "inode_need_killpriv" },
 { "inode_killpriv" },
 { "inode_getsecurity" },
 { "inode_setsecurity" },
 { "inode_listsecurity" },
 { "inode_getsecid" },
 { "inode_copy_up" },
 { "inode_copy_up_xattr" },
 { "kernfs_init_security" },
 { "file_permission" },
 { "file_alloc_security" },
 { "file_free_security" },
 { "file_ioctl" },
 { "mmap_addr" },
 { "mmap_file" },
 { "file_mprotect" },
 { "file_lock" },
 { "file_fcntl" },
 { "file_set_fowner" },
 { "file_send_sigiotask" },
 { "file_receive" },
 { "file_open" },
 { "task_alloc" },
 { "task_free" },
 { "cred_alloc_blank" },
 { "cred_free" },
 { "cred_prepare" },
 { "cred_transfer" },
 { "cred_getsecid" },
 { "kernel_act_as" },
 { "kernel_create_files_as" },
 { "kernel_module_request" },
 { "kernel_load_data" },
 { "kernel_post_load_data" },
 { "kernel_read_file" },
 { "kernel_post_read_file" },
 { "task_fix_setuid" },
 { "task_fix_setgid" },
 { "task_setpgid" },
 { "task_getpgid" },
 { "task_getsid" },
 { "task_getsecid" },
 { "task_setnice" },
 { "task_setioprio" },
 { "task_getioprio" },
 { "task_prlimit" },
 { "task_setrlimit" },
 { "task_setscheduler" },
 { "task_getscheduler" },
 { "task_movememory" },
 { "task_kill" },
 { "task_prctl" },
 { "task_to_inode" },
 { "ipc_permission" },
 { "ipc_getsecid" },
 { "msg_msg_alloc_security" },
 { "msg_msg_free_security" },
 { "msg_queue_alloc_security" },
 { "msg_queue_free_security" },
 { "msg_queue_associate" },
 { "msg_queue_msgctl" },
 { "msg_queue_msgsnd" },
 { "msg_queue_msgrcv" },
 { "shm_alloc_security" },
 { "shm_free_security" },
 { "shm_associate" },
 { "shm_shmctl" },
 { "shm_shmat" },
 { "sem_alloc_security" },
 { "sem_free_security" },
 { "sem_associate" },
 { "sem_semctl" },
 { "sem_semop" },
 { "netlink_send" },
 { "d_instantiate" },
 { "getprocattr" },
 { "setprocattr" },
 { "ismaclabel" },
 { "secid_to_secctx" },
 { "secctx_to_secid" },
 { "release_secctx" },
 { "inode_invalidate_secctx" },
 { "inode_notifysecctx" },
 { "inode_setsecctx" },
 { "inode_getsecctx" },
 { "post_notification" },
 { "watch_key" },
 { "unix_stream_connect" },
 { "unix_may_send" },
 { "socket_create" },
 { "socket_post_create" },
 { "socket_socketpair" },
 { "socket_bind" },
 { "socket_connect" },
 { "socket_listen" },
 { "socket_accept" },
 { "socket_sendmsg" },
 { "socket_recvmsg" },
 { "socket_getsockname" },
 { "socket_getpeername" },
 { "socket_getsockopt" },
 { "socket_setsockopt" },
 { "socket_shutdown" },
 { "socket_sock_rcv_skb" },
 { "socket_getpeersec_stream" },
 { "socket_getpeersec_dgram" },
 { "sk_alloc_security" },
 { "sk_free_security" },
 { "sk_clone_security" },
 { "sk_getsecid" },
 { "sock_graft" },
 { "inet_conn_request" },
 { "inet_csk_clone" },
 { "inet_conn_established" },
 { "secmark_relabel_packet" },
 { "secmark_refcount_inc" },
 { "secmark_refcount_dec" },
 { "req_classify_flow" },
 { "tun_dev_alloc_security" },
 { "tun_dev_free_security" },
 { "tun_dev_create" },
 { "tun_dev_attach_queue" },
 { "tun_dev_attach" },
 { "tun_dev_open" },
 { "sctp_assoc_request" },
 { "sctp_bind_connect" },
 { "sctp_sk_clone" },
 { "ib_pkey_access" },
 { "ib_endport_manage_subnet" },
 { "ib_alloc_security" },
 { "ib_free_security" },
 { "xfrm_policy_alloc_security" },
 { "xfrm_policy_clone_security" },
 { "xfrm_policy_free_security" },
 { "xfrm_policy_delete_security" },
 { "xfrm_state_alloc" },
 { "xfrm_state_alloc_acquire" },
 { "xfrm_state_free_security" },
 { "xfrm_state_delete_security" },
 { "xfrm_policy_lookup" },
 { "xfrm_state_pol_flow_match" },
 { "xfrm_decode_session" },
 { "key_alloc" },
 { "key_free" },
 { "key_permission" },
 { "key_getsecurity" },
 { "audit_rule_init" },
 { "audit_rule_known" },
 { "audit_rule_match" },
 { "audit_rule_free" },
 { "bpf" },
 { "bpf_map" },
 { "bpf_prog" },
 { "bpf_map_alloc_security" },
 { "bpf_map_free_security" },
 { "bpf_prog_alloc_security" },
 { "bpf_prog_free_security" },
 { "locked_down" },
 { "perf_event_open" },
 { "perf_event_alloc" },
 { "perf_event_free" },
 { "perf_event_read" },
 { "perf_event_write" },
 { "init" },
 { "settime64" },
 { "vm_enough_memory_mm" },
 { "bprm_set_creds" },
 { "bprm_check" },
 { "sb_alloc" },
 { "add_mnt_opt" },
 { "inode_alloc" },
 { "old_inode_init_security" },
 { "file_alloc" },
 { "prepare_creds" },
 { "msg_msg_alloc" },
 { "msg_queue_alloc" },
 { "shm_alloc" },
 { "sem_alloc" },
 { "sock_rcv_skb" },
 { "sk_alloc" },
 { "xfrm_policy_alloc" },
 { "xfrm_policy_clone" },
 { "xfrm_policy_delete" },
 { "xfrm_state_delete" },
 { "bpf_map_alloc" },
 { "bpf_prog_alloc" },
};

static const x64_thunk s_x64_thunks[] = {
  { "__x86_indirect_thunk_rax", UD_R_RAX },
  { "__x86_indirect_thunk_rbx", UD_R_RBX },
  { "__x86_indirect_thunk_rcx", UD_R_RCX },
  { "__x86_indirect_thunk_rdx", UD_R_RDX },
  { "__x86_indirect_thunk_rsi", UD_R_RSI },
  { "__x86_indirect_thunk_rdi", UD_R_RDI },
  { "__x86_indirect_thunk_rbp", UD_R_RBP },
  { "__x86_indirect_thunk_r8",  UD_R_R8 },
  { "__x86_indirect_thunk_r9",  UD_R_R9 },
  { "__x86_indirect_thunk_r10", UD_R_R10 },
  { "__x86_indirect_thunk_r11", UD_R_R11 },
  { "__x86_indirect_thunk_r12", UD_R_R12 },
  { "__x86_indirect_thunk_r13", UD_R_R13 },
  { "__x86_indirect_thunk_r14", UD_R_R14 },
  { "__x86_indirect_thunk_r15", UD_R_R15 },
};

section* find_section(const elfio& reader, a64 addr)
{
  Elf_Half n = reader.sections.size();
  for ( Elf_Half i = 0; i < n; ++i ) 
  {
    section* sec = reader.sections[i];
    auto start = sec->get_address();
    if ( (addr >= start) &&
         addr < (start + sec->get_size())
       )
      return sec;
  }
  return NULL;
}

const char *find_addr(const elfio& reader, a64 addr)
{
  section *s = find_section(reader, addr);
  if ( NULL == s )
    return NULL;
  if ( s->get_type() & SHT_NOBITS )
    return NULL;
  return s->get_data() + (addr - s->get_address());
}

void dump_arm64_fraces(const elfio& reader, a64 start, a64 end)
{
  Elf_Half n = reader.sections.size();
  if ( !n )
    return;
  for ( Elf_Half i = 0; i < n; ++i ) 
  {
    section* sec = reader.sections[i];
    if ( sec->get_type() == SHT_RELA )
    {
      const_relocation_section_accessor rsa(reader, sec);
      Elf_Xword relno = rsa.get_entries_num();
      for ( int i = 0; i < relno; i++ )
      {
         Elf64_Addr offset;
         Elf_Word   symbol;
         Elf_Word   type;
         Elf_Sxword addend;
         rsa.get_entry(i, offset, symbol, type, addend);
         if ( offset < start || offset > end )
           continue;
         if ( type != R_AARCH64_RELATIVE )
           continue;
         const char *name = lower_name_by_addr(addend);
         if ( name != NULL )
           printf("%p # %s\n", (void *)addend, name);
         else
           printf("%p\n", (void *)addend);
      }
    }
  }
}

size_t filter_arm64_relocs(const elfio& reader, a64 start, a64 end, a64 fstart, a64 fend, std::map<a64, a64> &filled)
{
  size_t res = 0;
  Elf_Half n = reader.sections.size();
  if ( !n )
    return 0;
  for ( Elf_Half i = 0; i < n; ++i ) 
  {
    section* sec = reader.sections[i];
    if ( sec->get_type() == SHT_RELA )
    {
      const_relocation_section_accessor rsa(reader, sec);
      Elf_Xword relno = rsa.get_entries_num();
      for ( int i = 0; i < relno; i++ )
      {
         Elf64_Addr offset;
         Elf_Word   symbol;
         Elf_Word   type;
         Elf_Sxword addend;
         rsa.get_entry(i, offset, symbol, type, addend);
         if ( offset < start || offset > end )
           continue;
         if ( type != R_AARCH64_RELATIVE )
           continue;
         if ( addend >= fstart && addend < fend )
         {
           filled[offset] = addend;
           res++;
         }
      }
    }
  }
  return res;
}

void dump_patched(a64 curr_addr, char *ptr, char *arg, sa64 delta)
{
   size_t off = 0;
   const char *name = lower_name_by_addr_with_off(curr_addr, &off);
   if ( name != NULL )
   {
     const char *pto = name_by_addr((a64)(arg - delta));
     if ( pto != NULL )
     {
        if ( off )
          printf("mem at %p (%s+%lX) patched to %p (%s)\n", ptr, name, off, arg, pto);
        else
          printf("mem at %p (%s) patched to %p (%s)\n", ptr, name, arg, pto);
      } else {
        if ( off )
          printf("mem at %p (%s+%lX) patched to %p\n", ptr, name, off, arg);
        else
          printf("mem at %p (%s) patched to %p\n", ptr, name, arg);
      }
  } else
     printf("mem at %p patched to %p\n", ptr, arg);
}

void dump_and_check(int fd, int opt_c, sa64 delta, int has_syms, std::map<a64, a64> &filled)
{
  for ( auto &c: filled )
  {
    auto curr_addr = c.first;
    auto addr = c.second;
    if ( g_opt_v )
    {
      size_t off = 0;
      const char *name = lower_name_by_addr_with_off(curr_addr, &off);
      if ( name != NULL )
      {
         const char *pto = name_by_addr(addr);
         if ( pto != NULL )
         {
           if ( off )
             printf("# %s+%lX -> %s\n", name, off, pto);
           else
             printf("# %s -> %s\n", name, pto);
           } else {
             if ( off )
               printf("# %s+%lX\n", name, off);
             else
               printf("# %s\n", name);
           }
         }
         printf("%p\n", (void *)curr_addr);
      }
#ifndef _MSC_VER
      if ( opt_c )
      {
         char *ptr = (char *)curr_addr + delta;
         char *arg = ptr;
         int err = ioctl(fd, IOCTL_READ_PTR, (int *)&arg);
         if ( err )
         {
           printf("read at %p failed, error %d (%s)\n", ptr, errno, strerror(errno));
           continue;
         }
         char *real = (char *)addr + delta;
         if ( real != arg )
         {
           if ( is_inside_kernel((unsigned long)arg) )
           {
              if ( !has_syms )
                printf("mem at %p: %p (must be %p)\n", ptr, arg, real);
              else 
              {
                size_t off = 0;
                const char *name = lower_name_by_addr_with_off(curr_addr, &off);
                if ( name != NULL )
                {
                  const char *pto = name_by_addr((a64)(arg - delta));
                  if ( pto != NULL )
                  {
                     if ( off )
                       printf("mem at %p (%s+%lX) patched to %p (%s)\n", ptr, name, off, arg, pto);
                     else
                       printf("mem at %p (%s) patched to %p (%s)\n", ptr, name, arg, pto);
                   } else {
                     if ( off )
                       printf("mem at %p (%s+%lX) patched to %p\n", ptr, name, off, arg);
                     else
                       printf("mem at %p (%s) patched to %p\n", ptr, name, arg);
                   }
                } else
                   printf("mem at %p: %p (must be %p)\n", ptr, arg, real);
              }
           } else 
           { // address not in kernel
              const char *mname = find_kmod((unsigned long)arg);
              if ( mname )
                printf("mem at %p: %p (must be %p) - patched by %s\n", ptr, arg, real, mname);
              else
                printf("mem at %p: %p (must be %p) - patched by UNKNOWN\n", ptr, arg, real);
            }
         }
      } /* opt_c */
#endif /* !_MSC_VER */
  }
}

#ifndef _MSC_VER
void dump_unnamed_kptr(unsigned long l, sa64 delta)
{
  if ( is_inside_kernel(l) )
  {
    const char *sname = name_by_addr(l - delta);
    if (sname != NULL)
      printf(" %p - kernel!%s\n", (void *)l, sname);
    else
      printf(" %p - kernel\n", (void *)l);
  } else {
    const char *mname = find_kmod(l);
    if ( mname )
      printf(" %p - %s\n", (void *)l, mname);
    else
      printf(" %p UNKNOWN\n", (void *)l);
  }
}

void dump_kptr(unsigned long l, const char *name, sa64 delta)
{
  if (is_inside_kernel(l))
  {
    const char *sname = name_by_addr(l - delta);
    if (sname != NULL)
      printf(" %s: %p - kernel!%s\n", name, (void *)l, sname);
    else
      printf(" %s: %p - kernel\n", name, (void *)l);
  }
  else {
    const char *mname = find_kmod(l);
    if (mname)
      printf(" %s: %p - %s\n", name, (void *)l, mname);
    else
      printf(" %s: %p - UNKNOWN\n", name, (void *)l);
  }
}

static size_t calc_uprobes_size(size_t n)
{
  return n * sizeof(one_uprobe) + sizeof(unsigned long);
}

static size_t calc_uprobes_clnt_size(size_t n)
{
  return n * sizeof(one_uprobe_consumer) + sizeof(unsigned long);
}

void dump_uprobes(int fd, sa64 delta)
{
  unsigned long a1 = get_addr("uprobes_tree");
  if ( !a1 )
  {
    printf("cannot find uprobes_tree\n");
    return;
  }
  unsigned long a2 = get_addr("uprobes_treelock");
  if ( !a2 )
  {
    printf("cannot find uprobes_treelock\n");
    return;
  }
  unsigned long params[2] = { a1 + delta, a2 + delta };
  int err = ioctl(fd, IOCTL_CNT_UPROBES, (int *)&params);
  if ( err )
  {
    printf("IOCTL_CNT_UPROBES failed, error %d (%s)\n", errno, strerror(errno));
    return;
  }
  printf("uprobes: %ld\n", params[0]);
  if ( !params[0] )
    return;
  size_t size = calc_uprobes_size(params[0]);
  char *buf = (char *)malloc(size);
  if ( !buf )
  {
    printf("cannot alloc buffer for uprobes, len %lX\n", size);
    return;
  }
  unsigned long *palias = (unsigned long *)buf;
  palias[0] = a1 + delta;
  palias[1] = a2 + delta;
  palias[2] = params[0];
  err = ioctl(fd, IOCTL_UPROBES, (int *)palias);
  if ( err )
  {
    printf("IOCTL_UPROBES failed, error %d (%s)\n", errno, strerror(errno));
  } else {
    one_uprobe *up = (one_uprobe *)(buf + sizeof(unsigned long));
    for ( auto cnt = 0; cnt < *palias; cnt++ )
    {
      printf("[%d] addr %p inode %p ino %ld clnts %ld offset %lX flags %lX %s\n", 
        cnt, up[cnt].addr, up[cnt].inode, up[cnt].i_no, up[cnt].cons_cnt, up[cnt].offset, up[cnt].flags, up[cnt].name);
      if ( !up[cnt].cons_cnt )
        continue;
      size_t client_size = calc_uprobes_clnt_size(up[cnt].cons_cnt);
      char *cbuf = (char *)malloc(client_size);
      if ( !cbuf )
      {
        printf("cannot alloc buffer for uprobe %p consumers, len %lX\n", up[cnt].addr, client_size);
        continue;
      }
      // form params for IOCTL_CNT_UPROBES
      unsigned long *calias = (unsigned long *)cbuf;
      calias[0] = a1 + delta;
      calias[1] = a2 + delta;
      calias[2] = (unsigned long)up[cnt].addr;
      calias[3] = up[cnt].cons_cnt;
      err = ioctl(fd, IOCTL_UPROBES_CONS, (int *)calias);
      if ( err )
      {
        printf("IOCTL_UPROBES_CONS for %p failed, error %d (%s)\n", up[cnt].addr, errno, strerror(errno));
        free(cbuf);
        continue;
      }
      // dump consumers
      one_uprobe_consumer *uc = (one_uprobe_consumer *)(cbuf + sizeof(unsigned long));
      for ( auto cnt2 = 0; cnt2 < *calias; cnt2++ )
      {
        printf(" consumer[%d] at %p\n", cnt2, uc[cnt2].addr);
        if ( uc[cnt2].handler )
          dump_kptr((unsigned long)uc[cnt2].handler, "  handler", delta);
        if ( uc[cnt2].ret_handler )
          dump_kptr((unsigned long)uc[cnt2].ret_handler, "  ret_handler", delta);
        if ( uc[cnt2].filter )
          dump_kptr((unsigned long)uc[cnt2].filter, "  filter", delta);
      }
      free(cbuf);
    }
  }
  free(buf);
}

static size_t calc_protosw_size(size_t n)
{
  return n * sizeof(one_protosw) + sizeof(unsigned long);
}

void dump_protosw(int fd, a64 list, a64 lock, sa64 delta, const char *what)
{
  printf("\n%s at %p:\n", what, (void *)(list + delta));
  for ( int i = 0; i < 11; i++ )
  {
    unsigned long args[4] = { list + delta, lock + delta, (unsigned long)i, 0 };
    int err = ioctl(fd, IOCTL_GET_PROTOSW, (int *)args);
    if ( err )
    {
      printf("IOCTL_GET_PROTOSW count for %d failed, error %d (%s)\n", i, errno, strerror(errno));
      continue;
    }
    if ( !args[0] )
      continue;
    size_t size = calc_protosw_size(args[0]);
    unsigned long *buf = (unsigned long *)malloc(size);
    if ( !buf )
      continue;
    buf[0] = list + delta;
    buf[1] = lock + delta;
    buf[2] = i;
    buf[3] = args[0];
    err = ioctl(fd, IOCTL_GET_PROTOSW, (int *)buf);
    if ( err )
    {
      printf("IOCTL_GET_PROTOSW for %d failed, error %d (%s)\n", i, errno, strerror(errno));
      free(buf);
      continue;
    }
    size = buf[0];
    printf("[%d]: count %ld\n", i, size);
    struct one_protosw *sb = (struct one_protosw *)(buf + 1);
    for ( size_t idx = 0; idx < size; idx++, sb++ )
    {
      printf(" addr %p type %d protocol %d\n", sb->addr, sb->type, sb->protocol);
      if ( sb->prot )
        dump_kptr((unsigned long)sb->prot, " prot", delta);
      if ( sb->ops )
        dump_kptr((unsigned long)sb->ops, " ops", delta);
    }
    free(buf);
  }
}

void dump_link_ops(int fd, a64 nca, sa64 delta)
{
  unsigned long args[2] = { nca + delta, 0 };
  int err = ioctl(fd, IOCTL_GET_LINKS_OPS, (int *)args);
  if ( err )
  {
    printf("IOCTL_GET_LINKS_OPS failed, error %d (%s)\n", errno, strerror(errno));
    return;
  }
  printf("\nlink_ops at %p: %ld\n", (void *)(nca + delta), args[0]);
  if ( !args[0] )
    return;
  size_t m = args[0];
  if ( m < 2 )
    m = 2;
  unsigned long *buf = (unsigned long *)malloc(m * sizeof(unsigned long));
  if ( !buf )
    return;
  buf[0] = nca + delta;
  buf[1] = args[0];
  err = ioctl(fd, IOCTL_GET_LINKS_OPS, (int *)buf);
  if ( err )
  {
    printf("IOCTL_GET_LINKS_OPS failed, error %d (%s)\n", errno, strerror(errno));
    free(buf);
    return;
  }
  for ( size_t j = 0; j < buf[0]; j++ )
  {
    dump_unnamed_kptr(buf[1 + j], delta);
  }
  free(buf);
}

static size_t calc_one_pernet_ops_size(size_t n)
{
  return n * sizeof(one_pernet_ops) + sizeof(unsigned long);
}

void dump_pernet_ops(int fd, a64 nca, a64 plock, sa64 delta)
{
  if ( !nca )
  {
    printf("cannot find pernet_list\n");
    return;
  }
  if ( !plock )
  {
    printf("cannot find pernet_ops_rwsem\n");
    return;
  }
  unsigned long cbuf[3] = { nca + delta, plock + delta, 0 };
  int err = ioctl(fd, IOCTL_GET_PERNET_OPS, (int *)cbuf);
  if ( err )
  {
    printf("IOCTL_GET_PERNET_OPS failed, error %d (%s)\n", errno, strerror(errno));
    return;
  }
  printf("\npernet_ops: %ld\n", cbuf[0]);
  if ( !cbuf[0] )
    return;
  size_t size = calc_one_pernet_ops_size(cbuf[0]);
  unsigned long *buf = (unsigned long *)malloc(size);
  if ( !buf )
    return;
  buf[0] = nca + delta;
  buf[1] = plock + delta;
  buf[2] = cbuf[0];
  err = ioctl(fd, IOCTL_GET_PERNET_OPS, (int *)buf);
  if ( err )
  {
    printf("IOCTL_GET_PERNET_OPS failed, error %d (%s)\n", errno, strerror(errno));
    free(buf);
    return;
  }
  size = buf[0];
  struct one_pernet_ops *sb = (struct one_pernet_ops *)(buf + 1);
  for ( size_t idx = 0; idx < size; idx++, sb++ )
  {
    printf(" [%ld] at %p:\n", idx, sb);
    if ( sb->init )
     dump_kptr((unsigned long)sb->init, " init", delta);
    if ( sb->exit )
     dump_kptr((unsigned long)sb->exit, " exit", delta);
    if ( sb->exit_batch )
     dump_kptr((unsigned long)sb->exit_batch, " exit_batch", delta);
  }
  free(buf);
}

static size_t calc_net_chains_size(size_t n)
{
  return (n + 1) * sizeof(unsigned long);
}

void dump_block_chain(int fd, a64 nca, sa64 delta, const char *name)
{
  unsigned long val = nca + delta;
  int err = ioctl(fd, IOCTL_CNTNTFYCHAIN, (int *)&val);
  if ( err )
  {
    printf("IOCTL_CNTSNTFYCHAIN for %s failed, error %d (%s)\n", name, errno, strerror(errno));
    return;
  }
  printf("\n%s at %p: count %ld\n", name, (void *)(nca + delta), val);
  if ( !val )
    return;
  size_t size = calc_net_chains_size(val);
  unsigned long *buf = (unsigned long *)malloc(size);
  if ( !buf )
    return;
  buf[0] = nca + delta;
  buf[1] = val;
  err = ioctl(fd, IOCTL_ENUMNTFYCHAIN, (int *)buf);
  if ( err )
  {
    printf("IOCTL_ENUMNTFYCHAIN for %s failed, error %d (%s)\n", name, errno, strerror(errno));
    free(buf);
    return;
  }
  for ( size_t i = 0; i < buf[0]; i++ )
  {
    printf(" [%ld]", i);
    dump_unnamed_kptr(buf[i+1], delta);
  }
}

void dump_net_chains(int fd, a64 nca, size_t cnt, sa64 delta)
{
  size_t size = calc_net_chains_size(cnt);
  unsigned long *buf = (unsigned long *)malloc(size);
  if ( !buf )
    return;
  buf[0] = nca + delta;
  buf[1] = cnt;
  int err = ioctl(fd, IOCTL_GET_NETDEV_CHAIN, (int *)buf);
  if ( err )
  {
    printf("IOCTL_GET_NETDEV_CHAIN failed, error %d (%s)\n", errno, strerror(errno));
    free(buf);
    return;
  }
  size = buf[0];
  for ( size_t j = 0; j < size; j++ )
  {
    dump_unnamed_kptr(buf[1 + j], delta);
  }
  free(buf);
}

static size_t calc_net_size(size_t n)
{
  return n * sizeof(one_net) + sizeof(unsigned long);
}

static size_t calc_net_dev_size(size_t n)
{
  return n * sizeof(one_net_dev) + sizeof(unsigned long);
}

void dump_nets(int fd, sa64 delta)
{
  unsigned long cnt = 0;
  int err = ioctl(fd, IOCTL_GET_NETS, (int *)&cnt);
  if ( err )
  {
    printf("IOCTL_GET_NETS count failed, error %d (%s)\n", errno, strerror(errno));
    return;
  }
  printf("nets: %ld\n", cnt);
  if ( !cnt )
    return;
  size_t size = calc_net_size(cnt);
  unsigned long *buf = (unsigned long *)malloc(size);
  if ( !buf )
    return;
  buf[0] = cnt;
  err = ioctl(fd, IOCTL_GET_NETS, (int *)buf);
  if ( err )
  {
    printf("IOCTL_GET_NETS failed, error %d (%s)\n", errno, strerror(errno));
    free(buf);
    return;
  }
  size = buf[0];
  struct one_net *sb = (struct one_net *)(buf + 1);
  for ( size_t idx = 0; idx < size; idx++, sb++ )
  {
    printf("Net[%ld]: %p ifindex %d rtnl %p genl_sock %p diag_nlsk %p uevent_sock %p dev_cnt %ld netdev_chain_cnt %ld\n",
      idx, sb->addr, sb->ifindex, sb->rtnl, sb->genl_sock, sb->diag_nlsk, sb->uevent_sock, sb->dev_cnt, sb->netdev_chain_cnt
    );
    if ( sb->rtnl_proto )
      dump_kptr((unsigned long)sb->rtnl_proto, "rtnl_proto", delta);
    if ( sb->rtnl_filter )
      dump_kptr((unsigned long)sb->rtnl_filter, "rtnl_filter", delta);
    if ( sb->genl_sock_proto )
      dump_kptr((unsigned long)sb->genl_sock_proto, "genl_sock_proto", delta);
    if ( sb->genl_sock_filter )
      dump_kptr((unsigned long)sb->genl_sock_filter, "genl_sock_filter", delta);
    if ( sb->diag_nlsk_proto )
      dump_kptr((unsigned long)sb->diag_nlsk_proto, "diag_nlsk_proto", delta);
    if ( sb->diag_nlsk_filter )
      dump_kptr((unsigned long)sb->diag_nlsk_filter, "diag_nlsk_filter", delta);
    if ( !sb->dev_cnt )
      continue;
    size_t dsize = calc_net_dev_size(sb->dev_cnt);
    unsigned long *dbuf = (unsigned long *)malloc(dsize);
    if ( !dbuf )
     continue;
    dbuf[0] = (unsigned long)sb->addr;
    dbuf[1] = sb->dev_cnt;
    err = ioctl(fd, IOCTL_GET_NET_DEVS, (int *)dbuf);
    if ( err )
    {
      printf("IOCTL_GET_NET_DEVS failed, error %d (%s)\n", errno, strerror(errno));
      free(dbuf);
      continue;
    }
    dsize = dbuf[0];
    struct one_net_dev *nd = (struct one_net_dev *)(dbuf + 1);
    for ( size_t j = 0; j < dsize; j++, nd++ )
    {
      printf(" Dev[%ld]: %p %s ntfy_cnt %ld type %d mtu %d min_mtu %d max_mtu %d\n", 
        j, nd->addr, nd->name, nd->netdev_chain_cnt, nd->type, nd->mtu, nd->min_mtu, nd->max_mtu
      );
      if ( nd->netdev_ops )
        dump_kptr((unsigned long)nd->netdev_ops, " netdev_ops", delta);
      if ( nd->ethtool_ops )
        dump_kptr((unsigned long)nd->ethtool_ops, " ethtool_ops", delta);
      if ( nd->l3mdev_ops )
        dump_kptr((unsigned long)nd->l3mdev_ops, " l3mdev_ops", delta);
      if ( nd->ndisc_ops )
        dump_kptr((unsigned long)nd->ndisc_ops, " ndisc_ops", delta);
      if ( nd->xfrmdev_ops )
        dump_kptr((unsigned long)nd->xfrmdev_ops, " xfrmdev_ops", delta);
      if ( nd->tlsdev_ops )
        dump_kptr((unsigned long)nd->tlsdev_ops, " tlsdev_ops", delta);
      if ( nd->header_ops )
        dump_kptr((unsigned long)nd->header_ops, " header_ops", delta);
      if ( nd->xdp_prog )
        dump_kptr((unsigned long)nd->xdp_prog, " xdp_prog", delta);
      if ( nd->rx_handler )
        dump_kptr((unsigned long)nd->rx_handler, " rx_handler", delta);
      if ( nd->rtnl_link_ops )
        dump_kptr((unsigned long)nd->rtnl_link_ops, " rtnl_link_ops", delta);
      if ( nd->num_hook_entries )
        printf("num_hook_entries: %ld\n", nd->num_hook_entries);
    }
    free(dbuf);
  }
  free(buf);
  // sock diags
  for ( int i = 0; i < AF_MAX; i++ )
  {
    one_sock_diag sd;
    sd.addr = (void *)i;
    err = ioctl(fd, IOCTL_GET_SOCK_DIAG, (int *)&sd);
    if ( err )
    {
      printf("IOCTL_GET_SOCK_DIAG(%d) failed, error %d (%s)\n", i, errno, strerror(errno));
      continue;
    }
    if ( !sd.addr )
      continue;
    printf("sock_diag[%d]: %p\n", i, sd.addr);
    if ( sd.dump )
      dump_kptr((unsigned long)sd.dump, "dump", delta);
    if ( sd.get_info )
      dump_kptr((unsigned long)sd.get_info, "get_info", delta);
    if ( sd.destroy )
      dump_kptr((unsigned long)sd.destroy, "destroy", delta);
  }
  // netdev chains
  unsigned long nca = get_addr("netdev_chain");
  if ( nca )
  {
    unsigned long nc[2];
    nc[0] = nca + delta;
    nc[1] = 0;
    err = ioctl(fd, IOCTL_GET_NETDEV_CHAIN, (int *)nc);
    if ( err )
      printf("IOCTL_GET_NETDEV_CHAIN failed, error %d (%s)\n", errno, strerror(errno));
    else {
      printf("\nnetdev_chain at %p: %ld\n", (void *)(nca + delta), nc[0]);
      if ( nc[0] )
        dump_net_chains(fd, nca, nc[0], delta);
    }
  } else
    printf("cannot find netdev_chain");
  // pernet ops
  nca = get_addr("pernet_list");
  auto plock = get_addr("pernet_ops_rwsem");
  dump_pernet_ops(fd, nca, plock, delta);
  // link ops
  nca = get_addr("link_ops");
  if ( !nca )
    printf("cannot find link_ops");
  else
    dump_link_ops(fd, nca, delta);
  // protosw
  nca = get_addr("inetsw");
  plock = get_addr("inetsw_lock");
  if ( !nca )
    printf("cannot find inetsw\n");
  else if ( !plock )
    printf("cannot find inetsw_lock\n");
  else
    dump_protosw(fd, nca, plock, delta, "inetsw");
  nca = get_addr("inetsw6");
  plock = get_addr("inetsw6_lock");
  if ( nca && plock )
    dump_protosw(fd, nca, plock, delta, "inetsw6");
  // network block chains
  nca = get_addr("netlink_chain");
  if ( nca )
    dump_block_chain(fd, nca, delta, "netlink_chain");
  nca = get_addr("inetaddr_chain");
  if ( nca )
    dump_block_chain(fd, nca, delta, "inetaddr_chain");
//  inet6addr_chain is ATOMIC_NOTIFIER
//  nca = get_addr("inet6addr_chain");
//  if ( nca )
//    dump_block_chain(fd, nca, delta, "inet6addr_chain");
  nca = get_addr("inetaddr_validator_chain");
  if ( nca )
    dump_block_chain(fd, nca, delta, "inetaddr_validator_chain");
  nca = get_addr("inet6addr_validator_chain");
  if ( nca )
    dump_block_chain(fd, nca, delta, "inet6addr_validator_chain");
}

static size_t calc_super_size(size_t n)
{
  return n * sizeof(one_super_block) + sizeof(unsigned long);
}

static size_t calc_inodes_size(size_t n)
{
  return n * sizeof(one_inode) + sizeof(unsigned long);
}

static size_t calc_marks_size(size_t n)
{
  return n * sizeof(one_fsnotify) + sizeof(unsigned long);
}

static size_t calc_mount_size(size_t n)
{
  return n * sizeof(one_mount) + sizeof(unsigned long);
}

// ripped from include/uapi/linux/stat.h
const char *get_mod_name(unsigned long mod)
{
   auto what = mod & 00170000;
   if ( what == 0140000 )
     return "SOCK";
   if ( what == 0120000 )
     return "LNK";
   if ( what == 0100000 )
     return "FILE";
   if ( what == 060000 )
     return "BLK";
   if ( what == 040000 )
     return "DIR";
   if ( what == 020000 )
     return "CHR";
   if ( what == 010000 )
     return "FIFO";
   return "???";
}

void dump_marks(unsigned long size, one_fsnotify *of, sa64 delta, const char *margin = "")
{
  std::string m = margin;
  m += " ops";
  for ( size_t k = 0; k < size; k++ )
  {
    printf("%s fsnotify[%ld] %p mask %X ignored_mask %X flags %X\n", margin, k, of[k].mark_addr, of[k].mask, of[k].ignored_mask, of[k].flags);
    if ( of[k].group )
      printf("%s group: %p\n", margin, of[k].group);
    if ( of[k].ops )
      dump_kptr((unsigned long)of[k].ops, m.c_str(), delta);
  }
}

void dump_super_blocks(int fd, sa64 delta)
{
  unsigned long cnt = 0;
  int err = ioctl(fd, IOCTL_GET_SUPERBLOCKS, (int *)&cnt);
  if ( err )
  {
    printf("IOCTL_GET_SUPERBLOCKS count failed, error %d (%s)\n", errno, strerror(errno));
    return;
  }
  printf("super-blocks: %ld\n", cnt);
  if ( !cnt )
    return;
  size_t size = calc_super_size(cnt);
  unsigned long *buf = (unsigned long *)malloc(size);
  if ( !buf )
    return;
  buf[0] = cnt;
  err = ioctl(fd, IOCTL_GET_SUPERBLOCKS, (int *)buf);
  if ( err )
  {
    printf("IOCTL_GET_SUPERBLOCKS failed, error %d (%s)\n", errno, strerror(errno));
    free(buf);
    return;
  }
  size = buf[0];
//  printf("size %ld\n", size);
  init_mountinfo();
  struct one_super_block *sb = (struct one_super_block *)(buf + 1);
  for ( size_t idx = 0; idx < size; idx++ )
  {
    printf("superblock[%ld] at %p dev %ld flags %lX inodes %ld %s mnt_count %ld root %p %s\n", idx, sb[idx].addr, sb[idx].dev, sb[idx].s_flags, sb[idx].inodes_cnt, sb[idx].s_id, 
      sb[idx].mount_count, sb[idx].s_root, sb[idx].root
    );
    if ( sb[idx].s_type )
      dump_kptr((unsigned long)sb[idx].s_type, "s_type", delta);
    if ( sb[idx].s_op )
      dump_kptr((unsigned long)sb[idx].s_op, "s_op", delta);
    if ( sb[idx].dq_op )
      dump_kptr((unsigned long)sb[idx].dq_op, "dq_op", delta);
    if ( sb[idx].s_qcop )
      dump_kptr((unsigned long)sb[idx].s_qcop, "s_qcop", delta);
    if ( sb[idx].s_export_op )
      dump_kptr((unsigned long)sb[idx].s_export_op, "s_export_op", delta);
    if ( sb[idx].s_d_op )
      dump_kptr((unsigned long)sb[idx].s_d_op, "s_d_op", delta);
    if ( sb[idx].s_fsnotify_mask || sb[idx].s_fsnotify_marks )
      printf(" s_fsnotify_mask: %lX s_fsnotify_marks %p\n", sb[idx].s_fsnotify_mask, sb[idx].s_fsnotify_marks);
    // dump super-block marks
    unsigned long sb_marks_arg[2] = { (unsigned long)sb[idx].addr, 0 };
    err = ioctl(fd, IOCTL_GET_SUPERBLOCK_MARKS, (int *)sb_marks_arg);
    if ( err )
    {
      printf("IOCTL_GET_SUPERBLOCK_MARKS count failed, error %d (%s)\n", errno, strerror(errno));
    } else if ( sb_marks_arg[1] )
    {
      size_t mmsize = calc_marks_size(sb_marks_arg[1]);
      unsigned long *mmbuf = (unsigned long *)malloc(mmsize);
      if ( mmbuf )
      {
        // params for IOCTL_GET_SUPERBLOCK_MARKS
        mmbuf[0] = (unsigned long)sb[idx].addr;
        mmbuf[1] = sb_marks_arg[1];
        err = ioctl(fd, IOCTL_GET_SUPERBLOCK_MARKS, (int *)mmbuf);
        if ( err )
          printf("IOCTL_GET_SUPERBLOCK_MARKS failed, error %d (%s)\n", errno, strerror(errno));
        else
          dump_marks(mmbuf[0], (one_fsnotify *)(mmbuf + 1), delta);
        free(mmbuf);
      }
    }
    // dump mounts
    if ( sb[idx].mount_count )
    {
      size_t msize = calc_mount_size(sb[idx].mount_count);
      unsigned long *mbuf = (unsigned long *)malloc(msize);
      if ( mbuf )
      {
        // params for IOCTL_GET_SUPERBLOCK_MOUNTS
        mbuf[0] = (unsigned long)sb[idx].addr;
        mbuf[1] = sb[idx].mount_count;
        err = ioctl(fd, IOCTL_GET_SUPERBLOCK_MOUNTS, (int *)mbuf);
        if ( err )
        {
          printf("IOCTL_GET_SUPERBLOCK_MOUNTS failed, error %d (%s)\n", errno, strerror(errno));
        } else {
          msize = mbuf[0];
          struct one_mount *mnt = (struct one_mount *)(mbuf + 1);
          for ( size_t j = 0; j < msize; j++ )
          {
            const char *path = NULL;
            if ( mnt[j].mnt_root[0] )
              path = mnt[j].mnt_root;
            else if ( mnt[j].root[0] )
              path = mnt[j].root;
            else if ( mnt[j].mnt_mp[0] )
              path = mnt[j].mnt_mp;
            else
              path = get_mnt(mnt[j].mnt_id);
            printf(" mnt[%ld] %p mark_cnt %ld mnt_id %d %s\n", j, mnt[j].addr, mnt[j].mark_count, mnt[j].mnt_id, path ? path : "");
            if ( !mnt[j].mark_count )
              continue;
            size_t mmsize = calc_marks_size(mnt[j].mark_count);
            unsigned long *mmbuf = (unsigned long *)malloc(mmsize);
            if ( !mmbuf )
              continue;
            // params for IOCTL_GET_MOUNT_MARKS
            mmbuf[0] = (unsigned long)sb[idx].addr;
            mmbuf[1] = (unsigned long)mnt[j].addr;
            mmbuf[2] = mnt[j].mark_count;
            err = ioctl(fd, IOCTL_GET_MOUNT_MARKS, (int *)mmbuf);
            if ( err )
            {
               printf("IOCTL_GET_MOUNT_MARKS failed, error %d (%s)\n", errno, strerror(errno));
               free(mmbuf);
               continue;
            }
            dump_marks(mmbuf[0], (one_fsnotify *)(mmbuf + 1), delta, "   ");
            free(mmbuf);
          }
        }
        free(mbuf);
      }
    }
    // dump inodes
    if ( !sb[idx].inodes_cnt )
      continue;
    auto isize = calc_inodes_size(sb[idx].inodes_cnt);
    unsigned long *ibuf = (unsigned long *)malloc(isize);
    if ( !ibuf )
      continue;
    // params for IOCTL_GET_SUPERBLOCK_INODES
    ibuf[0] = (unsigned long)sb[idx].addr;
    ibuf[1] = sb[idx].inodes_cnt;
    err = ioctl(fd, IOCTL_GET_SUPERBLOCK_INODES, (int *)ibuf);
    if ( err )
    {
      printf("IOCTL_GET_SUPERBLOCK_INODES failed, error %d (%s)\n", errno, strerror(errno));
      free(ibuf);
      continue;
    }
    isize = ibuf[0];
    struct one_inode *inod = (struct one_inode *)(ibuf + 1);
    for ( size_t j = 0; j < isize; j++ )
    {
      if ( !g_opt_v && !inod[j].i_fsnotify_mask && !inod[j].i_fsnotify_marks )
        continue;
      const char *mod = get_mod_name(inod[j].i_mode);
      printf("  inode[%ld] %p i_no %ld i_flags %X %s\n", j, inod[j].addr, inod[j].i_ino, inod[j].i_flags, mod);
      if ( inod[j].i_fsnotify_mask || inod[j].i_fsnotify_marks )
        printf("    i_fsnotify_mask: %lX i_fsnotify_marks %p count %ld\n", inod[j].i_fsnotify_mask, inod[j].i_fsnotify_marks, inod[j].mark_count);
      if ( !inod[j].mark_count )
        continue;
      size_t msize = calc_marks_size(inod[j].mark_count);
      unsigned long *fbuf = (unsigned long *)malloc(msize);
      if ( !fbuf )
        continue;
      // params for IOCTL_GET_INODE_MARKS
      fbuf[0] = (unsigned long)sb[idx].addr;
      fbuf[1] = (unsigned long)inod[j].addr;
      fbuf[2] = inod[j].mark_count;
      err = ioctl(fd, IOCTL_GET_INODE_MARKS, (int *)fbuf);
      if ( err )
      {
        printf("IOCTL_GET_INODE_MARKS failed, error %d (%s)\n", errno, strerror(errno));
        free(fbuf);
        continue;
      }
      dump_marks(fbuf[0], (one_fsnotify *)(fbuf + 1), delta, "   ");
      free(fbuf);
    }
    free(ibuf);
  }
  free(buf);
}

static size_t calc_kprobes_size(size_t n)
{
  return n * sizeof(one_kprobe) + sizeof(unsigned long);
}

void dump_kprobes(int fd, sa64 delta)
{
  unsigned long a1 = get_addr("kprobe_table");
  if ( !a1 )
  {
    printf("cannot find kprobe_table\n");
    return;
  }
  unsigned long a2 = get_addr("kprobe_mutex");
  if ( !a2 )
  {
    printf("cannot find kprobe_mutex\n");
    return;
  }
  size_t curr_n = 3;
  size_t ksize = calc_kprobes_size(curr_n);
  unsigned long *buf = (unsigned long *)malloc(ksize);
  if ( !buf )
    return;
  for ( int i = 0; i < 64; i++ )
  {
    unsigned long params[3] = { a1 + delta, a2 + delta, (unsigned long)i };
    int err = ioctl(fd, IOCTL_CNT_KPROBE_BUCKET, (int *)&params);
    if ( err )
    {
      printf("IOCTL_CNT_KPROBE_BUCKET(%d) failed, error %d (%s)\n", i, errno, strerror(errno));
      continue;
    }
    if ( !params[0] )
      continue;
    printf("kprobes[%d]: %ld\n", i, params[0]);
    // ok, we have some kprobes, read them all
    if ( params[0] > curr_n )
    {
      unsigned long *tmp;
      ksize = calc_kprobes_size(params[0]);
      tmp = (unsigned long *)malloc(ksize);
      if ( tmp == NULL )
        break;
      curr_n = params[0];
      free(buf);
      buf = tmp;
    }
    // fill params
    buf[0] = a1 + delta;
    buf[1] = a2 + delta;
    buf[2] = (unsigned long)i;
    buf[3] = params[0];
    err = ioctl(fd, IOCTL_GET_KPROBE_BUCKET, (int *)buf);
    if ( err )
    {
      printf("IOCTL_GET_KPROBE_BUCKET(%d) failed, error %d (%s)\n", i, errno, strerror(errno));
      continue;
    }
    // dump
    ksize = buf[0];
    struct one_kprobe *kp = (struct one_kprobe *)(buf + 1);
    for ( size_t idx = 0; idx < ksize; idx++ )
    {
      if ( kp[idx].is_aggr )
        printf(" kprobe at %p flags %X aggregated\n", kp[idx].kaddr, kp[idx].flags);
      else
        printf(" kprobe at %p flags %X\n", kp[idx].kaddr, kp[idx].flags);
      dump_kptr((unsigned long)kp[idx].addr, " addr", delta);
      if ( kp[idx].pre_handler )
        dump_kptr((unsigned long)kp[idx].pre_handler, " pre_handler", delta);
      if ( kp[idx].post_handler )
        dump_kptr((unsigned long)kp[idx].post_handler, " post_handler", delta);
    }
  }
  if ( buf != NULL )
    free(buf);
}

void install_urn(int fd, int action)
{
  unsigned long param = action;
  int err = ioctl(fd, IOCTL_TEST_URN, (int *)&param);
  if ( err )
    printf("install_urn(%d) failed, error %d (%s)\n", action, errno, strerror(errno));
}

static size_t calc_urntfy_size(size_t n)
{
  return (n + 1) * sizeof(unsigned long);
}

void dump_return_notifier_list(int fd, unsigned long this_off, unsigned long off, sa64 delta)
{
  int cpu_num = get_nprocs();
  size_t curr_n = 3;
  size_t size = calc_urntfy_size(curr_n);
  unsigned long *ntfy = (unsigned long *)malloc(size);
  if ( ntfy == NULL )
    return;
  for ( int i = 0; i < cpu_num; i++ )
  {
    unsigned long buf[3] = { (unsigned long)i, this_off, off };
    int err = ioctl(fd, IOCTL_CNT_RNL_PER_CPU, (int *)buf);
    if ( err )
    {
      printf("dump_return_notifier_list count for cpu_id %d failed, error %d (%s)\n", i, errno, strerror(errno));
      break;
    }
    if ( buf[0] )
      printf("cpu[%d]: head %p %ld\n", i, (void *)buf[0], buf[1]);
    else
      printf("cpu[%d]: %ld\n", i, buf[1]);
    if ( !buf[1] )
      continue; // no ntfy on this cpu
    // read ntfy
    if ( buf[1] > curr_n )
    {
      unsigned long *tmp;
      size = calc_urntfy_size(buf[1]);
      tmp = (unsigned long *)malloc(size);
      if ( tmp == NULL )
        break;
      curr_n = buf[1];
      free(ntfy);
      ntfy = tmp;
    }
    // fill params
    ntfy[0] = (unsigned long)i;
    ntfy[1] = this_off;
    ntfy[2] = off;
    ntfy[3] = buf[1];
    err = ioctl(fd, IOCTL_RNL_PER_CPU, (int *)ntfy);
    if ( err )
    {
      printf("dump_return_notifier_list for cpu_id %d cnt %ld failed, error %d (%s)\n", i, buf[1], errno, strerror(errno));
      break;
    }
    // dump
    size = ntfy[0];
    for ( size_t j = 0; j < size; j++ )
    {
      dump_kptr(ntfy[1 + j], "ntfy", delta);
    }
  }
  if ( ntfy != NULL )
    free(ntfy);
}

void dump_efivar_ops_field(int fd, char *ptr, const char *fname, sa64 delta)
{
  char *arg = ptr;
  int err = ioctl(fd, IOCTL_READ_PTR, (int *)&arg);
   if ( err )
     printf("cannot read %s at %p, err %d\n", fname, ptr, err);
   else if ( arg )
     dump_kptr((unsigned long)arg, fname, delta);
}

// generic_efivars is struct efivars - 2nd ptr is efivar_operations which has 5 function pointers
// see https://elixir.bootlin.com/linux/v5.14-rc7/source/include/linux/efi.h#L948
void dump_efivars(int fd, a64 saddr, sa64 delta)
{
   char *ptr = (char *)saddr + delta + 2 * sizeof(void *);
   char *arg = ptr;
   int err = ioctl(fd, IOCTL_READ_PTR, (int *)&arg);
   if ( err )
   {
      printf("dump_efivars: read at %p failed, error %d (%s)\n", ptr, errno, strerror(errno));
      return;
   }
   if ( !arg )
     return;
   if ( is_inside_kernel((unsigned long)arg) )
      printf("efivar_operations at %p: %p - kernel\n", ptr, arg);
   else {
     const char *mname = find_kmod((unsigned long)arg);
     if ( mname )
       printf("efivar_operations at %p: %p - %s\n", ptr, arg, mname);
     else
       printf("efivar_operations at %p: %p UNKNOWN\n", ptr, arg);
   }
   // dump all five fields
   ptr = arg;
   dump_efivar_ops_field(fd, ptr, "get_variable", delta);

   ptr += sizeof(void *);
   dump_efivar_ops_field(fd, ptr, "get_variable_next", delta);

   ptr += sizeof(void *);
   dump_efivar_ops_field(fd, ptr, "set_variable", delta);

   ptr += sizeof(void *);
   dump_efivar_ops_field(fd, ptr, "set_variable_nonblocking", delta);

   ptr += sizeof(void *);
   dump_efivar_ops_field(fd, ptr, "query_variable_store", delta);
}

void dump_usb_mon(int fd, a64 saddr, sa64 delta)
{
   char *ptr = (char *)saddr + delta;
   char *arg = ptr;
   int err = ioctl(fd, IOCTL_READ_PTR, (int *)&arg);
   if ( err )
   {
      printf("dump_usb_mon: read at %p failed, error %d (%s)\n", ptr, errno, strerror(errno));
      return;
   }
   if ( arg )
   {
     if ( is_inside_kernel((unsigned long)arg) )
       printf("mon_ops at %p: %p - kernel\n", (char *)saddr + delta, arg);
     else {
       const char *mname = find_kmod((unsigned long)arg);
       if ( mname )
         printf("mon_ops at %p: %p - %s\n", (char *)saddr + delta, arg, mname);
       else
         printf("mon_ops at %p: %p UNKNOWN\n", (char *)saddr + delta, arg);
     }
   } else 
     printf("mon_ops at %p: %p\n", (char *)saddr + delta, arg);
   if ( !arg )
     return;
   // see https://elixir.bootlin.com/linux/v5.14-rc7/source/include/linux/usb/hcd.h#L702
   // we need read 3 pointers at ptr
   ptr = arg;
   dump_efivar_ops_field(fd, ptr, "urb_submit", delta);

   ptr += sizeof(void *);
   dump_efivar_ops_field(fd, ptr, "urb_submit_error", delta);
 
   ptr += sizeof(void *);
   dump_efivar_ops_field(fd, ptr, "urb_complete", delta);
}

static size_t calc_tp_size(size_t n)
{
  return (n + 1) * sizeof(unsigned long);
}

void check_tracepoints(int fd, sa64 delta, addr_sym *tsyms, size_t tcount)
{
  // alloc enough memory for tracepoint info
  size_t i, j, curr_n = 3;
  size_t size = calc_tp_size(curr_n);
  unsigned long *ntfy = (unsigned long *)malloc(size);
  if ( ntfy == NULL )
    return;
  for ( i = 0; i < tcount; i++ )
  {
    a64 addr = (a64)((char *)tsyms[i].addr + delta);
    ntfy[0] = addr;
    int err = ioctl(fd, IOCTL_TRACEPOINT_INFO, (int *)ntfy);
    if ( err )
    {
      printf("error %d while read tracepoint info for %s at %p\n", err, tsyms[i].name, (void *)addr);
      continue;
    }
    printf(" %s at %p: enabled %d cnt %d\n", tsyms[i].name, (void *)addr, (int)ntfy[0], (int)ntfy[3]);
    // 1 - regfunc
    if ( ntfy[1] )
       dump_kptr(ntfy[1], " regfunc", delta);
    // 2 - unregfunc
    if ( ntfy[2] )
       dump_kptr(ntfy[2], " unregfunc", delta);
    if ( !ntfy[3] )
      continue;
    auto curr_cnt = ntfy[3];
    if ( curr_cnt > curr_n )
    {
      unsigned long *tmp;
      size = calc_tp_size(addr);
      tmp = (unsigned long *)malloc(size);
      if ( tmp == NULL )
        break;
      curr_n = curr_cnt;
      free(ntfy);
      ntfy = tmp;
    }
    // dump funcs
    ntfy[0] = addr;
    ntfy[1] = curr_cnt;
    err = ioctl(fd, IOCTL_TRACEPOINT_FUNCS, (int *)ntfy);
    if ( err )
    {
      printf("error %d while read tracepoint funcs for %s at %p\n", err, tsyms[i].name, (void *)addr);
      continue;
    }
    size = ntfy[0];
    for ( j = 0; j < size; j++ )
    {
      if ( is_inside_kernel(ntfy[1 + j]) )
        printf("  [%ld] %p - kernel\n", j, (void *)ntfy[1 + j]);
      else {
        const char *mname = find_kmod(ntfy[1 + j]);
        if ( mname )
          printf("  [%ld] %p - %s\n", j, (void *)ntfy[1 + j], mname);
        else
          printf("  [%ld] %p UNKNOWN\n", j, (void *)ntfy[1 + j]);
      }
    }
  }
  free(ntfy);
}
#endif /* !_MSC_VER */

int is_nop(unsigned char *body)
{
  // nop dword ptr [rax+rax+00h] - 0F 1F 44 00 00
  if ( body[0] == 0xF  &&
       body[1] == 0x1F &&
       body[2] == 0x44 &&
       body[3] == 0    &&
       body[4] == 0
     )
   return 1;
  // just 90
  if ( body[0] == 0x90 &&
       body[1] == 0x90 &&
       body[2] == 0x90 &&
       body[3] == 0x90 &&
       body[4] == 0x90
     )
   return 1;
  return 0;
}

int main(int argc, char **argv)
{
   // read options
   int opt_f = 0,
       opt_F = 0,
       opt_d = 0,
       opt_c = 0,
       opt_k = 0,
       opt_n = 0,
       opt_r = 0,
       opt_s = 0,
       opt_S = 0,
       opt_t = 0,
       opt_b = 0,
       opt_u = 0;
   int c;
   int fd = 0;
   while (1)
   {
     c = getopt(argc, argv, "bcdFfknrSstuv");
     if (c == -1)
	break;

     switch (c)
     {
        case 'b':
          opt_b = 1;
         break;
 	case 'F':
 	  opt_F = 1;
         break;
 	case 'f':
 	  opt_f = 1;
         break;
        case 'v':
          g_opt_v = 1;
         break;
        case 'd':
          opt_d = 1;
         break;
        case 'c':
          opt_c = 1;
         break;
        case 'k':
          opt_k = 1;
          opt_c = 1;
         break;
        case 'n':
          opt_n = 1;
         break;
        case 'r':
          opt_r = 1;
         break;
        case 's':
          opt_s = 1;
          opt_c = 1;
         break;
        case 'S':
          opt_S = 1;
         break;
        case 'u':
          opt_u = 1;
          opt_c = 1;
         break;
        case 't':
          opt_t = 1;
         break;
        default:
         usage(argv[0]);
     }
   }
   if (optind == argc)
     usage(argv[0]);

   elfio reader;
   int has_syms = 0;
   if ( !reader.load( argv[optind] ) ) 
   {
      printf( "File %s is not found or it is not an ELF file\n", argv[optind] );
      return 1;
   }
   optind++;
   Elf_Half n = reader.sections.size();
   for ( Elf_Half i = 0; i < n; ++i ) { // For all sections
     section* sec = reader.sections[i];
     if ( SHT_SYMTAB == sec->get_type() ||
          SHT_DYNSYM == sec->get_type() ) 
     {
       symbol_section_accessor symbols( reader, sec );
       if ( !read_syms(reader, symbols) )
         has_syms++;
     }
   }
   // try to find symbols
   if ( !has_syms && optind != argc )
   {
     int err = read_ksyms(argv[optind]);
     if ( err )
     {
       printf("cannot read %s, error %d\n", argv[optind], err);
       return err;
     }
     has_syms = 1;
     optind++;
   }
   sa64 delta = 0;
#ifndef _MSC_VER
   // open driver
   if ( opt_c ) 
   {
     fd = open("/dev/lkcd", 0);
     if ( -1 == fd )
     {
       printf("cannot open device, error %d\n", errno);
       opt_c = 0;
       goto end;
     }
     // find delta between symbols from system.map and loaded kernel
     auto symbol_a = get_addr("group_balance_cpu");
     if ( !symbol_a )
     {
       close(fd);
       fd = 0;
       opt_c = 0;
       goto end;
     } else {
       if ( read_kernel_area(fd) )
       {
         close(fd);
         fd = 0;
         opt_c = 0;
         goto end;
       }
       int err = init_kmods();
       if ( err )
       {
         printf("init_kmods failed, error %d\n", err);
         goto end;
       }
       printf("group_balance_cpu from symbols: %p\n", (void *)symbol_a);
       union ksym_params kparm;
       strcpy(kparm.name, "group_balance_cpu");
       err = ioctl(fd, IOCTL_RKSYM, (int *)&kparm);
       if ( err )
       {
         printf("IOCTL_RKSYM test failed, error %d\n", err);
         close(fd);
         fd = 0;
         opt_c = 0;
       } else {
         printf("group_balance_cpu: %p\n", (void *)kparm.addr);
         delta = (char *)kparm.addr - (char *)symbol_a;
         printf("delta: %lX\n", delta);
       }
     }
     // dump kprobes
     if ( opt_k && opt_c )
     {
       dump_kprobes(fd, delta);
       dump_uprobes(fd, delta);
     }
     // dump super-blocks
     if ( opt_F && opt_c )
       dump_super_blocks(fd, delta);
     if ( opt_c && opt_n )
       dump_nets(fd, delta);
     // check sysfs f_ops
     if ( opt_c && opt_s )
     {
       if ( optind == argc )
       {
         printf("where is files?\n");
         exit(6);
       }
       union kernfs_params kparm;
       for ( int idx = optind; idx < argc; idx++ )
       {
         strncpy(kparm.name, argv[idx], sizeof(kparm.name) - 1);
         kparm.name[sizeof(kparm.name) - 1] = 0;
         int err = ioctl(fd, IOCTL_KERNFS_NODE, (int *)&kparm);
         if ( err )
         {
           printf("IOCTL_KERNFS_NODE(%s) failed, error %d\n", argv[idx], err);
           continue;
         }
         printf("res %s: %p\n", argv[idx], (void *)kparm.res.addr);
         if ( kparm.res.addr )
         {
           // dump flags
           printf(" flags: %lX", kparm.res.flags);
           if ( kparm.res.flags & 1 )
             printf(" DIR");
           if ( kparm.res.flags & 2 )
             printf(" FILE");
           if ( kparm.res.flags & 4 )
             printf(" LINK");
           printf("\n");

           printf(" priv: %p\n", (void *)kparm.res.priv);
           if ( kparm.res.kobject )
             printf("kobject: %p\n", (void *)kparm.res.kobject);
           if ( kparm.res.ktype )
             dump_kptr(kparm.res.ktype, "ktype", delta);
           if ( kparm.res.sysfs_ops )
             dump_kptr(kparm.res.sysfs_ops, "sysfs_ops", delta);
           if ( kparm.res.show )
             dump_kptr(kparm.res.sysfs_ops, "sysfs_ops.show", delta);
           if ( kparm.res.store )
             dump_kptr(kparm.res.sysfs_ops, "sysfs_ops.store", delta);
         } else {
           printf(" inode: %p\n", (void *)kparm.res.flags);
           if ( kparm.res.s_op )
             dump_kptr(kparm.res.s_op, "s_op", delta);
           if ( kparm.res.priv )
             dump_kptr(kparm.res.priv, "inode->i_fop", delta);
           if ( kparm.res.ktype )
             dump_kptr(kparm.res.ktype, "debugfs_real_fops", delta);
           if ( kparm.res.sysfs_ops )
             dump_kptr(kparm.res.sysfs_ops, "private_data", delta);
         }
       }
     }
   }
end:
#endif /* _MSC_VER */
   // find .text section
   Elf64_Addr text_start = 0;
   Elf_Xword text_size = 0;
   section *text_section = NULL;
   for ( Elf_Half i = 0; i < n; ++i ) { // For all sections
     section* sec = reader.sections[i];
     if ( sec->get_name() == ".text" )
     {
       text_start = sec->get_address();
       text_size  = sec->get_size();
       text_section = sec;
       break;
     }
   }
   if ( has_syms )
   {
     // make some tests
     auto a1 = get_addr("__start_mcount_loc");
     printf("__start_mcount_loc: %p\n", (void *)a1);
     auto a2 = get_addr("__stop_mcount_loc");
     printf("__stop_mcount_loc: %p\n", (void *)a2);
     // if we had -f option
     if ( opt_f && a1 && a2 )
     {
       // under arm64 we need process relocs
       if ( reader.get_machine() == 183 )
         dump_arm64_fraces(reader, a1, a2);
       else {
         const a64 *data = (const a64 *)find_addr(reader, a1);
         if ( data != NULL )
         {
           for ( a64 i = a1; i < a2; i += sizeof(a64) )
           {
             a64 addr = *data;
             const char *name = lower_name_by_addr(addr);
             if ( name != NULL )
               printf("%p # %s\n", (void *)addr, name);
             else
               printf("%p\n", (void *)addr);
             data++;
#ifndef _MSC_VER
             if ( opt_c )
             {
               // filter out maybe discarded sections like .init.text
               if ( text_section != NULL &&
                    ( (addr < text_start) || (addr > (text_start + text_size)) )
                  )
                 continue;
               char *ptr = (char *)addr + delta;
               char *arg = ptr;
               int err = ioctl(fd, IOCTL_READ_PTR, (int *)&arg);
               if ( err )
                 printf("read ftrace at %p failed, error %d (%s)\n", ptr, errno, strerror(errno));
               else if ( !is_nop((unsigned char *)&arg) )
                 HexDump((unsigned char *)&arg, sizeof(arg));
             }
#endif /* !_MSC_VER */
           }
         }
       }
     }
   }

   if ( !text_start )
   {
     printf("cannot find .text\n");
     return 1;
   }
   for ( Elf_Half i = 0; i < n; ++i ) 
   {
     section* sec = reader.sections[i];
     if ( opt_r && sec->get_name() == ".rodata" )
     {
       std::map<a64, a64> filled;
       auto off = sec->get_offset();
       printf(".rodata section offset %lX\n", off);
       size_t count = 0;
       a64 curr_addr;
       // under arm64 we need count relocs in .data section       
       if ( reader.get_machine() == 183 )
       {
         a64 dstart = (a64)sec->get_address();
         count = filter_arm64_relocs(reader, dstart, dstart + sec->get_size(), (a64)text_start, (a64)(text_start + text_size), filled);
       } else {
         a64 *curr = (a64 *)sec->get_data();
         a64 *end  = (a64 *)((char *)curr + sec->get_size());
         curr_addr = sec->get_address();
         const endianess_convertor &conv = reader.get_convertor();
         for ( ; curr < end; curr++, curr_addr += sizeof(a64) )
         {
           auto addr = conv(*curr);
           if ( addr >= (a64)text_start &&
                addr < (a64)(text_start + text_size)
              )
           {
             count++;
             filled[curr_addr] = addr;
           }
         }
       }
       printf("found in .rodata %ld\n", count);
       // dump or check collected addresses
       if ( g_opt_v || opt_c )
         dump_and_check(fd, opt_c, delta, has_syms, filled);
       continue;
     }
     if ( sec->get_name() == ".data" )
     {
       std::map<a64, a64> filled;
       auto off = sec->get_offset();
       printf(".data section offset %lX\n", off);
       size_t count = 0;
       a64 curr_addr;
       if ( opt_u && has_syms )
       {
         a64 addr = get_addr("mon_ops");
         if ( !addr )
           printf("cannot find mon_ops\n");
#ifndef _MSC_VER
         else
           dump_usb_mon(fd, addr, delta);
#endif /* !_MSC_VER */
         addr = get_addr("generic_efivars");
         if ( !addr )
           printf("cannot find generic_efivars\n");
#ifndef _MSC_VER
         else
           dump_efivars(fd, addr, delta);
#endif /* !_MSC_VER */
       }
       if ( opt_t && has_syms )
       {
         size_t tcount = 0;
         a64 dstart = (a64)sec->get_address();
         struct addr_sym *tsyms = start_with("__tracepoint_", dstart, dstart + sec->get_size(), &tcount);
         if ( tsyms != NULL )
         {
           printf("found %ld tracepoints\n", tcount);
#ifdef _MSC_VER
           if ( g_opt_v )
           {
             for ( size_t i = 0; i < tcount; i++ )
               printf(" %p: %s\n", (void *)(tsyms[i].addr), tsyms[i].name);
           }
#else
           if ( opt_c )
             check_tracepoints(fd, delta, tsyms, tcount);
#endif /* _MSC_VER */
           free(tsyms);
         }
       }
       // under arm64 we need count relocs in .data section       
       if ( reader.get_machine() == 183 )
       {
         a64 dstart = (a64)sec->get_address();
         count = filter_arm64_relocs(reader, dstart, dstart + sec->get_size(), (a64)text_start, (a64)(text_start + text_size), filled);
       } else {
         a64 *curr = (a64 *)sec->get_data();
         a64 *end  = (a64 *)((char *)curr + sec->get_size());
         curr_addr = sec->get_address();
         const endianess_convertor &conv = reader.get_convertor();
         for ( ; curr < end; curr++, curr_addr += sizeof(a64) )
         {
           auto addr = conv(*curr);
           if ( addr >= (a64)text_start &&
                addr < (a64)(text_start + text_size)
              )
           {
             count++;
             filled[curr_addr] = addr;
           }
         }
       }
       printf("found %ld\n", count);
       // dump or check collected addresses
       if ( g_opt_v || opt_c )
         dump_and_check(fd, opt_c, delta, has_syms, filled);
       if ( opt_d )
       {
          dis_base *bd = NULL;
          if ( reader.get_machine() == 183 )
          {
            arm64_disasm *ad = new arm64_disasm(text_start, text_size, text_section->get_data(), sec->get_address(), sec->get_size());
            a64 addr = get_addr("__stack_chk_fail");
            if ( addr )
              ad->add_noreturn(addr);
            bd = ad;
          } else if ( reader.get_machine() == EM_X86_64 )
          {
            x64_disasm *x64 = new x64_disasm(text_start, text_size, text_section->get_data(), sec->get_address(), sec->get_size());
            // fill indirect thunks
            for ( auto &c: s_x64_thunks )
            {
              a64 thunk_addr = get_addr(c.name);
              if ( !thunk_addr )
                printf("cannot find %s\n", c.name);
              else
                x64->set_indirect_thunk(thunk_addr, c.reg);
             }
             a64 ntfy_addr = get_addr("fire_user_return_notifiers");
             if ( !ntfy_addr )
               printf("cannot find fire_user_return_notifiers\n");
             else {
               if ( x64->find_return_notifier_list(ntfy_addr) )
               {
                 unsigned long this_cpu_off = 0,
                               return_notifier_list = 0;
                 if ( x64->get_return_notifier_list(this_cpu_off, return_notifier_list) )
                 {
                   printf("this_cpu_off: %lX, return_notifier_list: %lX\n", this_cpu_off, return_notifier_list);
#ifndef _MSC_VER
                   if ( opt_c )
                   {
                     install_urn(fd, 1);
                     dump_return_notifier_list(fd, this_cpu_off, return_notifier_list, delta);
                     install_urn(fd, 0);
                   }
#endif
                 }
               } else
                 printf("cannot extract return_notifier_list\n");
             }
             bd = x64;
          } else {
            printf("no disasm for machine %d\n", reader.get_machine());
            break;
          }
          if ( opt_S )
          {
            s_security_hook_heads = get_addr("security_hook_heads");
            if ( !s_security_hook_heads )
            {
              printf("cannot find security_hook_heads\n");
              opt_S = 0;
            } else {
              int res = 0;
              bd->set_shook(s_security_hook_heads);
              for ( auto &sl: s_hooks )
              {
                std::string sl_name = "security_";
                sl_name += sl.name;
                sl.addr = get_addr(sl_name.c_str());
                if ( sl.addr )
                  res++;
              }
              if ( res )
                res = bd->process_sl(s_hooks);
              if ( !res )
                opt_S = 0;
              else if ( g_opt_v )
              {
                for ( auto &sl: s_hooks )
                {
                  if ( !sl.list )
                    continue;
                  printf("%s: %p\n", sl.name.c_str(), (void *)sl.list);
                }
              }
            }
          }
          // find bss if we need
          if ( opt_b )
          {
            for ( Elf_Half j = 0; j < n; ++j )
            {
              section* s = reader.sections[j];
              if ( (s->get_type() & SHT_NOBITS) && 
                   (s->get_name() == ".bss" )
                 )
              {
                a64 bss_addr = s->get_address();
                if ( g_opt_v )
                  printf(".bss address %p size %lX\n", (void *)bss_addr, s->get_size());
                bd->set_bss(bss_addr, s->get_size());
                break;
              }
            }
          }
          std::set<a64> out_res;
          size_t tcount = 0;
          struct addr_sym *tsyms = get_in_range(text_start, text_start + text_size, &tcount);
          if (tsyms != NULL)
          {
#ifdef _DEBUG
            a64 taddr = get_addr("netdev_store.isra.14");
            if ( taddr )
              bd->process(taddr, filled, out_res);
#endif /* _DEBUG */
            for (size_t i = 0; i < tcount; i++)
            {
#ifdef _DEBUG
              printf("%s:\n", tsyms[i].name);
#endif /* _DEBUG */
              bd->process(tsyms[i].addr, filled, out_res);
            }
            free(tsyms);
          }
          else
          {
            // now disasm some funcs - security_load_policy
            a64 faddr = get_addr("rcu_sched_clock_irq");
            if (faddr)
            {
              bd->process(faddr, filled, out_res);
            }
          }
          delete bd;
          printf("found with disasm: %ld\n", out_res.size());
          if ( g_opt_v )
          {
            for ( auto c: out_res )
            {
              size_t off = 0;
              const char *name = lower_name_by_addr_with_off(c, &off);
              if ( name != NULL )
              {
                if ( off )
                  printf("# %s+%lX\n", name, off);
                else
                  printf("# %s\n", name);
              }
              printf("%p\n", (void *)c);
            }
          }
#ifndef _MSC_VER
          if ( opt_c )
          {
            for ( auto c: out_res )
            {
              char *ptr = (char *)c + delta;
              char *arg = ptr;
              int err = ioctl(fd, IOCTL_READ_PTR, (int *)&arg);
              if ( err )
                printf("read at %p failed, error %d (%s)\n", ptr, errno, strerror(errno));
              else if ( arg != NULL )
              {
                 if ( is_inside_kernel((unsigned long)arg) )
                 {
                    if ( !has_syms )
                      printf("mem at %p: %p\n", ptr, arg);
                    else
                      dump_patched(c, ptr, arg, delta);
                 } else {
                    const char *mname = find_kmod((unsigned long)arg);
                    if ( mname )
                      printf("mem at %p: %p - patched by %s\n", ptr, arg, mname);
                    else
                      printf("mem at %p: %p - patched by UNKNOWN\n", ptr, arg);
                 }
              }
            }
          } // opt_c
#endif /* !_MSC_VER */
       } // opt_d
       break;
     }
   }
#ifndef _MSC_VER
   if ( fd )
     close(fd);
#endif /* _MSC_VER */
}
